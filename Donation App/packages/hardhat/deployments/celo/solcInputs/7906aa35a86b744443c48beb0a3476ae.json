{
  "language": "Solidity",
  "sources": {
    "contracts/Donation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title DonationApp\r\n * @dev A comprehensive donation platform with campaigns, goals, and transparent tracking\r\n */\r\ncontract DonationApp {\r\n    struct Campaign {\r\n        string title;\r\n        string description;\r\n        address payable beneficiary;\r\n        uint256 goal;\r\n        uint256 raised;\r\n        uint256 deadline;\r\n        bool active;\r\n        bool goalReached;\r\n        uint256 donorCount;\r\n        address creator;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    struct Donation {\r\n        address donor;\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n        uint256 campaignId;\r\n        string message;\r\n    }\r\n\r\n    // State variables\r\n    mapping(uint256 => Campaign) public campaigns;\r\n    mapping(uint256 => Donation[]) public campaignDonations;\r\n    mapping(address => uint256[]) public userCampaigns;\r\n    mapping(address => uint256[]) public userDonations;\r\n    \r\n    uint256 public nextCampaignId;\r\n    uint256 public totalCampaigns;\r\n    uint256 public totalDonationsAmount;\r\n    uint256 public totalDonationsCount;\r\n    \r\n    // Platform fee (in basis points, 100 = 1%)\r\n    uint256 public platformFee = 250; // 2.5%\r\n    address public platformOwner;\r\n    uint256 public platformBalance;\r\n\r\n    // Events\r\n    event CampaignCreated(\r\n        uint256 indexed campaignId,\r\n        address indexed creator,\r\n        address indexed beneficiary,\r\n        string title,\r\n        uint256 goal,\r\n        uint256 deadline\r\n    );\r\n    \r\n    event DonationMade(\r\n        uint256 indexed campaignId,\r\n        address indexed donor,\r\n        uint256 amount,\r\n        string message\r\n    );\r\n    \r\n    event CampaignGoalReached(uint256 indexed campaignId, uint256 totalRaised);\r\n    event CampaignWithdrawn(uint256 indexed campaignId, address indexed beneficiary, uint256 amount);\r\n    event CampaignCancelled(uint256 indexed campaignId, address indexed creator);\r\n    event PlatformFeeUpdated(uint256 newFee);\r\n\r\n    // Errors\r\n    error InvalidGoal();\r\n    error InvalidDeadline();\r\n    error CampaignNotActive();\r\n    error CampaignExpired();\r\n    error NoFundsToWithdraw();\r\n    error UnauthorizedAccess();\r\n    error TransferFailed();\r\n    error InvalidFee();\r\n\r\n    // Modifiers\r\n    modifier onlyPlatformOwner() {\r\n        require(msg.sender == platformOwner, \"Only platform owner\");\r\n        _;\r\n    }\r\n\r\n    modifier campaignExists(uint256 _campaignId) {\r\n        require(_campaignId < nextCampaignId, \"Campaign does not exist\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCampaignCreator(uint256 _campaignId) {\r\n        require(campaigns[_campaignId].creator == msg.sender, \"Only campaign creator\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        platformOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new donation campaign\r\n     * @param _title Campaign title\r\n     * @param _description Campaign description\r\n     * @param _beneficiary Address that will receive the donations\r\n     * @param _goal Funding goal in wei\r\n     * @param _durationInDays Duration of campaign in days\r\n     */\r\n    function createCampaign(\r\n        string memory _title,\r\n        string memory _description,\r\n        address payable _beneficiary,\r\n        uint256 _goal,\r\n        uint256 _durationInDays\r\n    ) external returns (uint256 campaignId) {\r\n        if (_goal == 0) revert InvalidGoal();\r\n        if (_durationInDays == 0) revert InvalidDeadline();\r\n        require(_beneficiary != address(0), \"Invalid beneficiary address\");\r\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\r\n\r\n        uint256 deadline = block.timestamp + (_durationInDays * 1 days);\r\n        \r\n        campaignId = nextCampaignId++;\r\n        \r\n        campaigns[campaignId] = Campaign({\r\n            title: _title,\r\n            description: _description,\r\n            beneficiary: _beneficiary,\r\n            goal: _goal,\r\n            raised: 0,\r\n            deadline: deadline,\r\n            active: true,\r\n            goalReached: false,\r\n            donorCount: 0,\r\n            creator: msg.sender,\r\n            createdAt: block.timestamp\r\n        });\r\n\r\n        userCampaigns[msg.sender].push(campaignId);\r\n        totalCampaigns++;\r\n\r\n        emit CampaignCreated(campaignId, msg.sender, _beneficiary, _title, _goal, deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Donate to a campaign\r\n     * @param _campaignId ID of the campaign to donate to\r\n     * @param _message Optional message from donor\r\n     */\r\n    function donate(uint256 _campaignId, string memory _message) \r\n        external \r\n        payable \r\n        campaignExists(_campaignId) \r\n    {\r\n        require(msg.value > 0, \"Donation must be greater than 0\");\r\n        \r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        \r\n        if (!campaign.active) revert CampaignNotActive();\r\n        if (block.timestamp > campaign.deadline) revert CampaignExpired();\r\n\r\n        // Calculate platform fee\r\n        uint256 fee = (msg.value * platformFee) / 10000;\r\n        uint256 donationAmount = msg.value - fee;\r\n\r\n        // Update campaign\r\n        campaign.raised += donationAmount;\r\n        campaign.donorCount++;\r\n        \r\n        // Check if goal is reached\r\n        if (!campaign.goalReached && campaign.raised >= campaign.goal) {\r\n            campaign.goalReached = true;\r\n            emit CampaignGoalReached(_campaignId, campaign.raised);\r\n        }\r\n\r\n        // Record donation\r\n        Donation memory newDonation = Donation({\r\n            donor: msg.sender,\r\n            amount: donationAmount,\r\n            timestamp: block.timestamp,\r\n            campaignId: _campaignId,\r\n            message: _message\r\n        });\r\n\r\n        campaignDonations[_campaignId].push(newDonation);\r\n        userDonations[msg.sender].push(_campaignId);\r\n\r\n        // Update totals\r\n        totalDonationsAmount += donationAmount;\r\n        totalDonationsCount++;\r\n        platformBalance += fee;\r\n\r\n        emit DonationMade(_campaignId, msg.sender, donationAmount, _message);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw funds from campaign (only beneficiary)\r\n     * @param _campaignId ID of the campaign\r\n     */\r\n    function withdrawFunds(uint256 _campaignId) \r\n        external \r\n        campaignExists(_campaignId) \r\n    {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        \r\n        require(msg.sender == campaign.beneficiary, \"Only beneficiary can withdraw\");\r\n        if (campaign.raised == 0) revert NoFundsToWithdraw();\r\n\r\n        uint256 amount = campaign.raised;\r\n        campaign.raised = 0;\r\n        campaign.active = false;\r\n\r\n        (bool success, ) = campaign.beneficiary.call{value: amount}(\"\");\r\n        if (!success) revert TransferFailed();\r\n\r\n        emit CampaignWithdrawn(_campaignId, campaign.beneficiary, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel campaign (only creator, only if no donations)\r\n     * @param _campaignId ID of the campaign\r\n     */\r\n    function cancelCampaign(uint256 _campaignId) \r\n        external \r\n        campaignExists(_campaignId)\r\n        onlyCampaignCreator(_campaignId)\r\n    {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        require(campaign.raised == 0, \"Cannot cancel campaign with donations\");\r\n        \r\n        campaign.active = false;\r\n        \r\n        emit CampaignCancelled(_campaignId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Get campaign details\r\n     */\r\n    function getCampaign(uint256 _campaignId) \r\n        external \r\n        view \r\n        campaignExists(_campaignId)\r\n        returns (\r\n            string memory title,\r\n            string memory description,\r\n            address beneficiary,\r\n            uint256 goal,\r\n            uint256 raised,\r\n            uint256 deadline,\r\n            bool active,\r\n            bool goalReached,\r\n            uint256 donorCount,\r\n            address creator,\r\n            uint256 createdAt\r\n        ) \r\n    {\r\n        Campaign memory campaign = campaigns[_campaignId];\r\n        return (\r\n            campaign.title,\r\n            campaign.description,\r\n            campaign.beneficiary,\r\n            campaign.goal,\r\n            campaign.raised,\r\n            campaign.deadline,\r\n            campaign.active,\r\n            campaign.goalReached,\r\n            campaign.donorCount,\r\n            campaign.creator,\r\n            campaign.createdAt\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get campaign progress percentage\r\n     * @param _campaignId ID of the campaign\r\n     * @return percentage Progress as percentage (0-100+)\r\n     */\r\n    function getCampaignProgress(uint256 _campaignId) \r\n        external \r\n        view \r\n        campaignExists(_campaignId)\r\n        returns (uint256 percentage) \r\n    {\r\n        Campaign memory campaign = campaigns[_campaignId];\r\n        if (campaign.goal == 0) return 0;\r\n        return (campaign.raised * 100) / campaign.goal;\r\n    }\r\n\r\n    /**\r\n     * @dev Get donations for a campaign\r\n     * @param _campaignId ID of the campaign\r\n     * @return donations Array of donations\r\n     */\r\n    function getCampaignDonations(uint256 _campaignId) \r\n        external \r\n        view \r\n        campaignExists(_campaignId)\r\n        returns (Donation[] memory donations) \r\n    {\r\n        return campaignDonations[_campaignId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get campaigns created by a user\r\n     * @param _user Address of the user\r\n     * @return campaignIds Array of campaign IDs\r\n     */\r\n    function getUserCampaigns(address _user) \r\n        external \r\n        view \r\n        returns (uint256[] memory campaignIds) \r\n    {\r\n        return userCampaigns[_user];\r\n    }\r\n\r\n    /**\r\n     * @dev Get campaigns a user has donated to\r\n     * @param _user Address of the user\r\n     * @return campaignIds Array of campaign IDs\r\n     */\r\n    function getUserDonations(address _user) \r\n        external \r\n        view \r\n        returns (uint256[] memory campaignIds) \r\n    {\r\n        return userDonations[_user];\r\n    }\r\n\r\n    /**\r\n     * @dev Get active campaigns (view function for frontend)\r\n     * @param _start Start index\r\n     * @param _limit Number of campaigns to return\r\n     */\r\n    function getActiveCampaigns(uint256 _start, uint256 _limit) \r\n        external \r\n        view \r\n        returns (uint256[] memory activeCampaigns) \r\n    {\r\n        uint256[] memory temp = new uint256[](nextCampaignId);\r\n        uint256 count = 0;\r\n        \r\n        for (uint256 i = _start; i < nextCampaignId && count < _limit; i++) {\r\n            if (campaigns[i].active && block.timestamp <= campaigns[i].deadline) {\r\n                temp[count] = i;\r\n                count++;\r\n            }\r\n        }\r\n        \r\n        // Resize array\r\n        activeCampaigns = new uint256[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            activeCampaigns[i] = temp[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check if campaign deadline has passed\r\n     * @param _campaignId ID of the campaign\r\n     */\r\n    function isCampaignExpired(uint256 _campaignId) \r\n        external \r\n        view \r\n        campaignExists(_campaignId)\r\n        returns (bool) \r\n    {\r\n        return block.timestamp > campaigns[_campaignId].deadline;\r\n    }\r\n\r\n    /**\r\n     * @dev Get time remaining for campaign\r\n     * @param _campaignId ID of the campaign\r\n     * @return timeLeft Seconds remaining, 0 if expired\r\n     */\r\n    function getTimeLeft(uint256 _campaignId) \r\n        external \r\n        view \r\n        campaignExists(_campaignId)\r\n        returns (uint256 timeLeft) \r\n    {\r\n        uint256 deadline = campaigns[_campaignId].deadline;\r\n        if (block.timestamp >= deadline) {\r\n            return 0;\r\n        }\r\n        return deadline - block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Update platform fee (only platform owner)\r\n     * @param _newFee New fee in basis points (100 = 1%)\r\n     */\r\n    function updatePlatformFee(uint256 _newFee) external onlyPlatformOwner {\r\n        if (_newFee > 1000) revert InvalidFee(); // Max 10%\r\n        platformFee = _newFee;\r\n        emit PlatformFeeUpdated(_newFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw platform fees (only platform owner)\r\n     */\r\n    function withdrawPlatformFees() external onlyPlatformOwner {\r\n        uint256 amount = platformBalance;\r\n        platformBalance = 0;\r\n        \r\n        (bool success, ) = payable(platformOwner).call{value: amount}(\"\");\r\n        if (!success) revert TransferFailed();\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer platform ownership\r\n     * @param _newOwner New platform owner address\r\n     */\r\n    function transferOwnership(address _newOwner) external onlyPlatformOwner {\r\n        require(_newOwner != address(0), \"Invalid address\");\r\n        platformOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Get platform statistics\r\n     */\r\n    function getPlatformStats() external view returns (\r\n        uint256 _totalCampaigns,\r\n        uint256 _totalDonationsAmount,\r\n        uint256 _totalDonationsCount,\r\n        uint256 _platformFee,\r\n        uint256 _platformBalance\r\n    ) {\r\n        return (\r\n            totalCampaigns,\r\n            totalDonationsAmount,\r\n            totalDonationsCount,\r\n            platformFee,\r\n            platformBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency pause function (only platform owner)\r\n     */\r\n    function emergencyPause() external onlyPlatformOwner {\r\n        // In a production contract, you'd implement a proper pause mechanism\r\n        // This is a simplified version\r\n        selfdestruct(payable(platformOwner));\r\n    }\r\n\r\n    // Prevent accidental ETH sends\r\n    receive() external payable {\r\n        revert(\"Use donate() function to make donations\");\r\n    }\r\n\r\n    fallback() external payable {\r\n        revert(\"Function not found. Use donate() to make donations\");\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}